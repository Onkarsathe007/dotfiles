#open i3 config
i3jump() {
  cd ~/.config/i3
  nvim config  # or use `nano` or `code` or whatever editor
}
#clear + ls
cl() {
  clear
  ls --color=auto
}
#to open an nvim 
v() {
  if [ "$#" -eq 0 ]; then
    nvim .
  else
    nvim "$@"
  fi
}
#clean up trash
cleanup() {
  echo "Cleaning up the following directories and files:"
  find . \( -name "node_modules" -o -name "venv" -o -name ".venv" \) -type d -print
  find . -name ".DS_Store" -print

  echo
  read "confirm?Are you sure you want to delete these? (y/N): "
  if [[ "$confirm" == [yY] ]]; then
    find . \( -name "node_modules" -o -name "venv" -o -name ".venv" \) -type d -prune -exec rm -rf '{}' +
    find . -name ".DS_Store" -delete
    echo "Cleanup complete."
  else
    echo "Cleanup canceled."
  fi
}
#auto commit message generate :
gencommit() {
  if ! command -v tgpt &>/dev/null; then
    echo "tgpt is not installed or not in PATH."
    return 1
  fi

  local diff
  diff=$(git diff --cached)

  if [[ -z "$diff" ]]; then
    echo "No staged changes to commit."
    return 1
  fi

  # Optional extra message
  local extra_msg=""
  while [[ "$1" != "" ]]; do
    if [[ "$1" == "-m" && -n "$2" ]]; then
      extra_msg="$2"
      shift 2
    else
      shift
    fi
  done

  local prompt="You are a helpful commit message generator.
Create a short and clean git commit message using the Conventional Commits format (feat, fix, chore, etc).
Use this format:
<type>(<scope>): <summary>
<newline>
- Bullet points for each change grouped under 'Added:', 'Changed:', 'Removed:', etc.

Avoid repetition, emojis, or verbose descriptions.
Here is the git diff:
$diff"

  local message
  message=$(echo "$prompt" | tgpt -q | sed '/Loading/d' | sed 's/^[^[:alnum:]]*//' | sed '/^$/d')

  echo -e "\nGenerated commit message:\n$message"
  if [[ -n "$extra_msg" ]]; then
    echo -e "\nExtra message: $extra_msg"
  fi

  echo -n "Use this commit message? (y/N): "
  read -r confirm

  if [[ "$confirm" =~ ^[yY]$ ]]; then
    if [[ -n "$extra_msg" ]]; then
      git commit -m "$message" -m "$extra_msg"
    else
      git commit -m "$message"
    fi
  else
    echo "Commit canceled."
  fi
}

#for pdf 


pdf() {
  if [[ -f "$1" ]]; then
    zathura "$1" & disown
  else
    echo "File not found: $1"
  fi
}

#To Extract the files
extract() {
  if [ -f "$1" ]; then
    case "$1" in
      *.tar.bz2) tar xjf "$1" ;;
      *.tar.gz)  tar xzf "$1" ;;
      *.bz2)     bunzip2 "$1" ;;
      *.rar)     unrar x "$1" ;;
      *.gz)      gunzip "$1" ;;
      *.tar)     tar xf "$1" ;;
      *.tbz2)    tar xjf "$1" ;;
      *.tgz)     tar xzf "$1" ;;
      *.zip)     unzip "$1" ;;
      *.Z)       uncompress "$1" ;;
      *.7z)      7z x "$1" ;;
      *) echo "Don't know how to extract '$1'..." ;;
    esac
  else
    echo "'$1' is not a valid file"
  fi
}

note() {
  echo "$(date): $*" >> ~/notes.txt
  echo "Note saved!"
}

trash() {
  mkdir -p ~/.trash
  mv "$@" ~/.trash/
  echo "Moved to trash"
}

timer() {
  echo "Timer started for $1 seconds..."
  sleep "$1" && notify-send "‚è∞ Time's up!" || echo "‚è∞ Done!"
}


lampp() {
  # Start XAMPP
  sudo /opt/lampp/lampp start 
}

# Java compile and run shortcut
function jrun() {
  if [ -z "$1" ]; then
    echo "Usage: jrun <JavaFileNameWithoutExtension>"
    return 1
  fi

  local file="$1.java"

  if [ ! -f "$file" ]; then
    echo "File $file does not exist."
    return 1
  fi

  echo "Compiling $file..."
  javac "$file"

  if [ $? -eq 0 ]; then
    echo "Running $1..."
    java "$1"
  else
    echo "Compilation failed."
  fi
}

function life(){
  birth_install=$(stat -c %W /); current=$(date +%s); time_progression=$((current - birth_install)); days_difference=$((time_progression / 86400)); echo $days_difference days
}


#!/usr/bin/env bash

# Target date
TARGET_DATE="2025-11-30 00:00:00"

goal() {
    # Current timestamp
    NOW_TS=$(date +%s)

    # Target timestamp
    TARGET_TS=$(date -d "$TARGET_DATE" +%s)

    # If target date passed
    if [ "$TARGET_TS" -le "$NOW_TS" ]; then
        echo "üéâ Congratulations! The date has already passed."
        return
    fi

    # Parse current date components
    NOW_YEAR=$(date +%Y)
    NOW_MONTH=$(date +%m)
    NOW_DAY=$(date +%d)

    # Parse target date components
    TARGET_YEAR=$(date -d "$TARGET_DATE" +%Y)
    TARGET_MONTH=$(date -d "$TARGET_DATE" +%m)
    TARGET_DAY=$(date -d "$TARGET_DATE" +%d)

    # Calculate months difference
    TOTAL_MONTHS=$(( (TARGET_YEAR - NOW_YEAR)*12 + (10#$TARGET_MONTH - 10#$NOW_MONTH) ))

    # If target day < current day, reduce month by 1
    if [ "$TARGET_DAY" -lt "$NOW_DAY" ]; then
        TOTAL_MONTHS=$((TOTAL_MONTHS - 1))
    fi

    # Get the date after adding TOTAL_MONTHS to current date
    INTERMEDIATE_DATE=$(date -d "$NOW_YEAR-$NOW_MONTH-01 +$TOTAL_MONTHS month")

    # Calculate remaining seconds from that date to target
    INTERMEDIATE_TS=$(date -d "$INTERMEDIATE_DATE" +%s)
    REMAINING_SECONDS=$(( TARGET_TS - INTERMEDIATE_TS ))

    # Break down remaining seconds
    REM_DAYS=$(( REMAINING_SECONDS / 86400 ))
    REM_HOURS=$(( (REMAINING_SECONDS % 86400) / 3600 ))
    REM_MINUTES=$(( (REMAINING_SECONDS % 3600) / 60 ))
    REM_SECONDS=$(( REMAINING_SECONDS % 60 ))

    echo "‚è≥ Time remaining until 30 Nov 2025:"
    echo "$TOTAL_MONTHS months, $REM_DAYS days, $REM_HOURS hours, $REM_MINUTES minutes, $REM_SECONDS seconds"
}

# Use zoxide for direct navigation with fuzzy matching for typos
z() {
  local result
  
  # First try exact matching
  result="$(zoxide query -- "$@" 2>/dev/null)"
  
  if [[ -n "$result" ]]; then
    cd "$result"
    return 0
  fi
  
  # If exact match fails, try fuzzy matching
  local query="$*"
  local all_dirs
  local best_match
  local best_score=0
  
  # Get all directories from zoxide
  all_dirs=($(zoxide query --list))
  
  # Enhanced fuzzy matching algorithm
  for dir in "${all_dirs[@]}"; do
    local dir_name=$(basename "$dir")
    local score=0
    
    # Calculate similarity score
    local query_lower=$(echo "$query" | tr '[:upper:]' '[:lower:]')
    local dir_lower=$(echo "$dir_name" | tr '[:upper:]' '[:lower:]')
    
    # Method 1: Substring match gets highest priority
    if [[ "$dir_lower" == *"$query_lower"* ]]; then
      score=100
    # Method 2: Check if all query characters appear in order
    else
      local query_len=${#query_lower}
      local dir_len=${#dir_lower}
      local matches=0
      local query_pos=0
      local consecutive_bonus=0
      
      for ((i=0; i<dir_len && query_pos<query_len; i++)); do
        if [[ "${dir_lower:$i:1}" == "${query_lower:$query_pos:1}" ]]; then
          ((matches++))
          ((query_pos++))
          # Bonus for consecutive matches
          if [[ $i -gt 0 && "${dir_lower:$((i-1)):1}" == "${query_lower:$((query_pos-2)):1}" ]]; then
            ((consecutive_bonus += 5))
          fi
        fi
      done
      
      # Calculate final score
      if [[ $matches -gt 0 ]]; then
        score=$((matches * 80 / query_len + consecutive_bonus))
        
        # Bonus for matching the beginning of the word
        if [[ "${dir_lower:0:1}" == "${query_lower:0:1}" ]]; then
          ((score += 20))
        fi
        
        # Penalty for length difference
        local len_diff=$((dir_len - query_len))
        if [[ $len_diff -gt 0 ]]; then
          score=$((score - len_diff * 2))
        fi
      fi
    fi
    
    # Ensure score doesn't go negative
    if [[ $score -lt 0 ]]; then
      score=0
    fi
    
    # Update best match if this score is higher
    if [[ $score -gt $best_score ]]; then
      best_score=$score
      best_match="$dir"
    fi
  done
  
  # If we found a decent match (at least 25% similarity), use it
  if [[ $best_score -ge 25 && -n "$best_match" ]]; then
    cd "$best_match"
  else
    echo "No directory found matching: $query"
  fi
}

# Use zoxide with fzf for interactive selection
zinter() {
  cd "$(zoxide query --interactive)"
}
